---
title: "meep-matcher.Rmd"
author: "mikec964"
date: "7/31/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
file.sources = list.files(c("scripts"),
                          pattern="*.R$", full.names=TRUE,
                          ignore.case=TRUE)
sapply(file.sources, source)
```

# Overview
Here's the plan, so far:

1. Load the collection of games (and ratings) of the user. All users are gamers, but the person we're building the recommendation for is the customer.
We'll build a table with a row per game.

2. For each game in the customer's collection, get the gamers that also rated
it.
Row per gamer/rating.
    * We might request all of these in parallel, pause, then load what we can  
    * Add to table, some columns empty.

3. For each of those gamers, load their collections (and ratings)  
    * Request all, pause, load  
    * Extend and update table


# Load game collection for the customer
Note that for some customers, the number of columns might be different.
If a customer has a game with wishlist=1, then for that row the column
"wishlistpriority" is added.

```{r echo=FALSE, message=TRUE, warning=TRUE}
customer <- "mikec"
collection.tbl <- GetGamerCollection(customer)
head(collection.tbl)
#eg.tbl <- GetGamerCollection("educatedgravy")
#head(eg.df)
```
# For each game in the customer collection, get the ratings
We'll append these rows to our customer collection table. Possible problems ahead:

* Each game could have 10,000 or more ratings...

    * 100 games is a million rows  
    * Reading ratings 100 at a time (per API) means 10,000 queries!

* On the new rows the gamer, game, game_id, rating columns will be filled, but
the own, owned, wishlist columns will be empty until we load data for each gamer

* Since ratings are sorted best to worst, and delivered in pages of 100, we could:

    * Stop getting ratings below 5  
    * Select some pages to sample

For now:

 * Load the first page of (100) ratings  
 * Only load for the first game in the customer collection, until this works

```{r echo=FALSE, message=FALSE, warning=TRUE}
s <- 10
sample.tbl <- sample_n(collection.tbl, s)
for(game in 1:s) {
  print(sprintf("Loading ratings for %s: %s.", sample.tbl[game, "game"], sample.tbl[game, "game.id"]))
  game.ratings.tbl <- GetGameRatings(sample.tbl[[game, "game.id"]])
  if(game == 1) {
    ratings.tbl <- game.ratings.tbl
  } else {
    ratings.tbl <- bind_rows(ratings.tbl, game.ratings.tbl)
  }
}
head(ratings.tbl)
```

# Combine customer game ratings with other gamer's ratings
Now, we want to combine these rows with the main collection table. This will be unnecessarily ugly. We'll rearrange and add columns (with NAs) to the game_ratings.tbl until it looks like collection.tbl.

```{r echo=FALSE, message=FALSE, warning=TRUE}

# na.col <- rep(NA, dim(collection.tbl)[1])
# add_cols <- setdiff(colnames(collection.tbl), colnames(ratings.tbl))
# wide_ratings <- ratings.tbl

#for(c in add_cols) {
#  print(c)
#  wide_ratings <- add_column(wide_ratings, na.col)
#}
```
