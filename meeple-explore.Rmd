---
title: "meeple-explore.Rmd"
author: "mikec964"
date: "10/17/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(readr)
library(tidyr)

colors.neon4 <- c("#a763ff", "#ffd063", "#bbff63", "#ff63bb")
```

# Explore the game, customer, and adjacent gamer data

## Reload the data
This data was downloaded from BGG using their XML interface, extracted into
tables, and stored locally for faster recall.

| variable            | count     | Description
| --------            |----------:| -----------
| customer            | 1         | user
| collection.customer | 160       | games in collection
| games.ratings       | 1,385,920 | (tall) for games in collection
| games.attrs         | 5954      | (tall) avg of 37 per game, 160 games
| gamers.adjacent     | 158,705   | have games in common
| gamers.selected     | 500       | subset of adjacent_gamers
| collection.selected | 80,342    | games owned by selected_gamers + customer

'collection' columns are per gamer, like "owned".
  gamer+game.id is unique, but game name might not be
  The same game may have names in different languages or editions
'games' columns are per game, like "description", categories and mechanics.


```{r echo=FALSE, message=FALSE, warning=TRUE}
customer <- "mikec"
collection.customer <- read_tsv("tables/collection-customer.tsv")
games.ratings       <- read_tsv("tables/games-ratings.tsv")
games.ratings       <- games.ratings[, c("game.id", "game", "gamer", "rating")]
games.attrs         <- read_tsv("tables/games-attrs.tsv")
collection.selected <- read_tsv("tables/collection-selected.tsv")
collection.selected <- bind_rows(collection.customer, collection.selected)
gamers.adjacent     <- unique(games.ratings$gamer)
gamers.selected     <- read_lines("tables/gamers-selected.tsv")
```

### Build wide table of game attributes
```{r echo=FALSE, message=TRUE, warning=TRUE}
# Only games that have been rated
games.details <- collection.customer[!is.na(collection.customer$rating),]

# These attributes have a single value; each attribute can be a column heading
attrs.unique <- c("yearpublished", "minplayers", "maxplayers",
                  "playingtime", "minplaytime", "maxplaytime", 
                  "description", "comments")
for(a in attrs.unique) {
  v <- games.attrs[games.attrs$key == a, c("game.id", "value")]
  names(v)[-1] <- a
  games.details <- left_join(games.details, v, by="game.id")
}

# These attributes have N values; each value can be a column heading
attrs.tags <- c("boardgamecategory", "boardgamemechanic")
names(attrs.tags) <- c("category", "mechanic")
for(a in attrs.tags) {
  v <- games.attrs[games.attrs$key == a, c("game.id", "value")]
  v$TF <- 1
  v <- v %>% spread(value, TF, fill = 0)
  names(v)[-1] <- paste0(names(a), ".", names(v)[-1])
  games.details <- left_join(games.details, v, by="game.id")
}

# Get unique categories and mechanics (from customer's games)
games.categories <- unique(
  games.attrs[games.attrs$key == attrs.tags["category"],]$value)
games.mechanics <- unique(
  games.attrs[games.attrs$key == attrs.tags["mechanic"],]$value)

# Build grids of games, gamers, and ratings
  # A game can be in a gamer's collection as "wanted" or "owned" but not rated
  # todo:
  #   filter expansions?
  #   fill with -1 if not rated
  #   fill with "NA" if the game isn't on their list

# Rows = 160 customer's games, Cols = 158,706 gamers
games.ratings <- distinct(games.ratings, game.id, gamer, .keep_all = TRUE)
customer.grid <- spread(games.ratings, gamer, rating)

# Rows = 16,685 games, Cols = 502 adjacent gamers
collection.ratings <- collection.selected[, c("game.id", "game", "gamer", "rating")]
collection.ratings <- distinct(collection.ratings, game.id, gamer, .keep_all = TRUE)
collection.grid <- spread(collection.ratings, gamer, rating)

# Rows = 160 games, cols = 252 of "most" adjacent gamers
# gamers.most = 2nd to 3rd quartile of # of games rated
gamers.details <- collection.selected %>% 
  group_by(gamer) %>% 
  count %>% 
  arrange(n)
names(gamers.details)[-1] <- c("ratings")
gamers.most <- gamers.details[(gamers.details$ratings >= 27) &
                                (gamers.details$ratings <= 168),]
# gamers.most$ratings <- NULL
most.ratings <- collection.selected %>%
  semi_join(gamers.most, by = "gamer") %>%
  semi_join(collection.customer, by = "game.id") %>%
  distinct(game.id, gamer, .keep_all = TRUE) %>%
  select(game.id, game, gamer, rating)
most.grid <- spread(most.ratings, gamer, rating)
### This is 224 rows instead of 160 because some games have dupe names.
### Todo: Remove dupe names.
```

## Explore the customer
* What's the distribution of his/her ratings?
* Distribution of game attributes: published, #players, playtime
* Distribution of game tags: categories, mechanics
* Correlation between ratings and attributes

```{r echo=FALSE, message=TRUE, warning=TRUE}
ggplot(games.details, aes(rating)) +
  ggtitle("Customer Ratings of Collection") +
  geom_bar(fill=colors.neon4[1])

ggplot(games.details, aes(x=yearpublished, y=rating)) +
  ggtitle("Cutomer's Rating vs. Publish Date") +
  geom_jitter(alpha=0.5, color=colors.neon4[1])

ggplot(games.details, aes(x=playingtime, y=rating)) +
  ggtitle("Cutomer's Rating vs. Playing Time") +
  geom_jitter(alpha=0.5, color=colors.neon4[1])

ggplot(games.details, aes(x=maxplayers, y=rating)) +
  ggtitle("Cutomer's Rating vs. Max Players") +
  geom_jitter(alpha=0.5, color=colors.neon4[1])

```


```{r echo=FALSE, message=TRUE, warning=TRUE}
# Which mechanics do I prefer? (# of games per, ratings of games per)
# Which categories do I prefer?

# Per mechanic, get the # of games and mean rating
mechanics.details <- data_frame(mechanic=games.mechanics,
                                count=0,
                                mean=0.0)
#mechanics.details$count <- as.integer(0)
#mechanics.details$mean <- as.numeric(0)
# for(m in g.mechanics$mechanics) {
#   g <- g.mechanics[g.mechanics$mechanics == m,]
#   r <- games.ratings[g$game.id, "rating"]
#   mechanics.details[mechanics.details$mechanic == m,]$count <- count(g)
#   mechanics.details[mechanics.details$mechanic == m,]$mean <- mean(r$rating)
# }
# mechanics.details$count <- as.integer(mechanics.details$count)
# mechanics.details$mean <- as.numeric(mechanics.details$mean)

categories.details <- data_frame(category=games.categories,
                                 count=0,
                                 mean=0)
# for(c in g.categories$categories) {
#   g <- g.categories[g.categories$categories == c,]
#   r <- games.ratings[g$game.id, "rating"]
#   categories.details[categories.details$category == c,]$count <- count(g)
#   categories.details[categories.details$category == c,]$mean <- mean(r$rating)
# }
# categories.details$count <- as.integer(categories.details$count)
# categories.details$mean <- as.numeric(categories.details$mean)
```

## Explore gamers
* How many games do gamers rate?
* What is distribution of their ratings?
* Distribution of game attributes: published, playtime, maxplayers

```{r echo=FALSE, message=TRUE, warning=TRUE}
# From selected gamers, find min, max, avg number of games rated
# gamers.selected is list of gamers
# collection.selected is all the games they've rated

ggplot(gamers.most, aes(ratings)) +
  geom_density(fill=colors.neon4[2]) +
  ggtitle("Ratings per Gamer, 2nd-3rd quartile")

# Ratings of all adjacent gamers
ggplot(games.ratings, aes(rating)) +
  geom_bar(fill=colors.neon4[3]) +
  ggtitle("All Ratings of Collection")
  
# How many games does each adjacent gamers have in common with the customer?
#   In games.ratings, how many games does each gamer own?
c <- games.ratings %>% 
  group_by(gamer) %>% 
  count()
ggplot(c, aes(n)) +
  geom_density(fill=colors.neon4[1]) + 
  ggtitle("Games in common")

# safe bet: matrix completion
# fresh pick: graph network

```

## Explore games
* How well-known are the games (how many ratings each)?
* How well-regarded are the games (mean, sd, scatter of ratings)?
* When were the games published?
* Which game categories dominate?
* Which game mechanics dominate?
* Which game designers dominate?
* Which game publishers dominate?

