---
title: "meep-matcher.Rmd"
author: "mikec964"
date: "8/1/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
file.sources = list.files(c("scripts"),
                          pattern="*.R$", full.names=TRUE,
                          ignore.case=TRUE)
sapply(file.sources, source)
```

# Overview
Here's the plan, so far:

1. **Load the customer's collection.**  
Load the collection of games (and ratings) of the user. All users are gamers,
but the person we're building the recommendation for is the customer.
We'll build a Collections table with a row per game.

2. **Per game, load the ratings.**  
For each game in the customer's collection, get the gamers that also rated
it. Row per gamer/rating.

    * Request all of these in parallel, pause, then load what we can  
    * Add to Ratings table

3. **Rank gamers that are like the customer.**

4. **Per ranking, load the gamer's collections.**  
For gamers that are similar to the customer, load their collections. Games
in their collections that are unknown to the customer are possible
recommendations.

    * Request all of these in parallel, pause, then load what we can


# Load the customer's collection
This is probably in the range of 10 to 200 games. 
Note that for some customers, the number of columns might be different.
If a customer has a game with wishlist=1, then for that row the column
"wishlistpriority" is added.

```{r echo=FALSE, message=FALSE, warning=TRUE}
customer <- "mikec"
collection.tbl <- GetGamerCollection(customer)
head(collection.tbl)
#eg.tbl <- GetGamerCollection("educatedgravy")
#head(eg.df)
```


# Per game, load the ratings
For each game in the collection, we'll collect the data and ratings. The data
are things like number of players and year published. Ratings is a list of
potentially thousands of ratings between 1 and 10.

Sizing the data: Each game could have 10,000 or more ratings. The API delivers
100 ratings at a time, so it could take 100 queries to load all for a game. 
If the customer has 100 games, that's 10,000 queries!

I've written a simple cache system so that subsequent reads come from local
storage.

```{r echo=FALSE, message=FALSE, warning=TRUE}
sample.tbl <- collection.tbl
# sample.tbl <- sample_n(collection.tbl, 2)  # Uncomment to load fewer games
View(sample.tbl)
for(g in 1:dim(sample.tbl)[1]) {
  game.id <- sample.tbl[[g, "game.id"]]
  num.comments <- GetGameData(game.id)[[1, "comments"]]
  num.pages <- as.integer(((num.comments - 1) / 100) + 1)
  print(sprintf("%s of %s, loading %s comments for %s, %s", 
                g, dim(sample.tbl)[1], num.comments, game.id, sample.tbl[[g, "game"]]))
  if(g == 1 && p == 1) {
    games.tbl <- GetGameData(game.id)
  } else {
    games.tbl <- bind_rows(games.tbl, GetGameData(game.id))
  }
  for(p in 1:num.pages) {
    if(g==1 && p == 1) {
      ratings.tbl <- GetGameRatings(game.id, page=p)
    } else {
      ratings.tbl <- bind_rows(ratings.tbl, GetGameRatings(game.id, page=p))
    }
  }
}
View(games.tbl)
View(ratings.tbl)
```


# Visualize the ratings

```{r echo=FALSE, message=TRUE, warning=TRUE}

```


# Rank gamers that are like the customer
The general formula is:  
  * For the games we have rated, find gamers who have rated them similarly  
  * The more games they agree with us on, the better

```{r echo=FALSE, message=TRUE, warning=TRUE}

```


# Per rating, load the gamer's collections
We should make a unique list of gamer IDs that have rated games, then load
their collections.

```{r echo=FALSE, message=TRUE, warning=TRUE}

```

